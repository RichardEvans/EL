\section{Semantics and Decision Procedure}
\label{coreEL}

In this section we provide our key semantic results. 
We define a partial ordering $\MODELLEQ$ on models, and show how the partial ordering can be extended into a bounded lattice.
We use the bounded lattice to provide a decision procedure.

\subsection{A semantic characterisation of elementary equivalence}\label{elementaryEquivalence}

Elementary equivalence induces a notion of model equivalence: two
models are elementarily equivalent exactly when they make the same
formulae true. Elementary equivalent as a concept thus relies on
eremic logic even for its definition. We now present an alternative
characterisation that is purely semantic, using the concept of
(mutual) simulation from process theory. Apart from its intrinsic
interest, this characterisation will also be crucial for proving
completeness of the proof rules.

We first define a pre-order $\MODELLEQ$ on models by extending the
notion of simulation on labeled transition systems to eremic
models. Then we prove an alternative characterisation of $\MODELLEQ$
in terms of set-inclusion of the theories induced by models. We then
show that two models are elementarily equivalent exactly when they are
related by $\MODELLEQ$ and by $\MODELLEQ^{-1}$.

\begin{definition}
Let $\LLL_i = (S_i, \rightarrow_i, \lambda_i)$ be eremic transition
systems for $i = 1, 2$.  A relation $\RRR \subseteq S_1 \times S_2$ is
a \emph{simulation from $\LLL_1$ to $\LLL_2$}, provided:
\begin{itemize} 

\item $\RRR$ is a simulation on the underlying transition systems. 

\item Whenever $(x, y) \in \RRR$ then also $\lambda_1(x) \supseteq
  \lambda_2(y)$.

\end{itemize}

\NI If $\MMM_i = (\LLL_i, x_i)$ are models, we say $\RRR$ is a
\emph{simulation from $\MMM_1$ to $\MMM_2$}, provided the following hold.

\begin{itemize}

\item $\RRR$ is a simulation from $\LLL_1$ to $\LLL_2$ as eremic transition systems.

\item  $(x_1, x_2) \in \RRR$. 

\end{itemize}

\end{definition}

\NI Note that the only difference form the usual definition of
simulation is the additional requirement on the node labelling
functions $\lambda_1$ and $\lambda_2$.

\begin{definition}
The largest simulation from $\MMM_1$ to $\MMM_2$ is denoted $\MMM_1
\SIM \MMM_2$.  It is easy to see that $\SIM$ is itself a
simulation from $\MMM_1$ to $\MMM_2$, and the union of all such
simulations.  If $\MMM_1 \SIM \MMM_2$ we say $\MMM_2$
\emph{simulates} $\MMM_1$.
\end{definition}

\begin{definition}
Let $\THEORY{\MMM}$ be the \emph{theory} of $\MMM$, i.e.~the formulae
made true by $\MMM$, i.e.~$\THEORY{\MMM} = \{\phi\ |\ \MMM \models
\phi \}$.
\end{definition}

\NI We give an alternative characterisation on $\SIM^{-1}$ in terms of
theories of models. In what follows, we will mostly be interested in
$\SIM^{-1}$, so we give it its own symbol.

\begin{definition}
Let $\MODELLEQ$  be short for $\SIM^{-1}$.
\end{definition}

\NI Figure \ref{figure:leq} gives some examples of models and how they
are related by $\MODELLEQ$.

\input{figure:leq}

\begin{theorem}\label{theorem:completeLattice}
$\MMM' \MODELLEQ \MMM$ if and only if
$\THEORY{\MMM} \subseteq  \THEORY{\MMM'}$.
\end{theorem}

\begin{proof}
Assume $\MMM' \MODELLEQ \MMM$ and $\MMM \models \phi$.  We must show
$\MMM' \models \phi$.  Let $\MMM = (\LLL, w)$ and $\MMM' = (\LLL',
w')$.  The proof proceeds by induction on $\phi$.  The cases for
$\top$ and $\land$ are trivial.  Assume $\phi = \MAY{a}\psi$ and
assume $(\LLL, w) \models \MAY{a}\psi$.  Then $w \xrightarrow{a} x$
and $(\LLL, x) \models \psi$.  As $\MMM'$ simulates $\MMM$, there is
an $x'$ such that $(x,x') \in R$ and $w' \xrightarrow{a} x'$.  By the
induction hypothesis, $(\LLL', x') \models \psi$.  Therefore, by the
semantic clause for $\MAY{}$, $(\LLL', w') \models \MAY{a}\psi$.  Assume
now that $\phi = \; ! \; A$, for some finite $A \subseteq \Sigma$, and
that $(\LLL, w) \models \; ! \; A$.  By the semantic clause for $!$,
$\lambda(w) \subseteq A$.  Since $(\LLL', w') \MODELLEQ (\LLL, w)$, by
the definition of simulation of eremic transition systems, $\lambda(w)
\supseteq \lambda'(w')$.  Therefore, $\lambda'(w') \subseteq
\lambda(w) \subseteq A$.  Therefore, by the semantic clause for $!$,
$(\LLL', w') \models \; ! \; A$.

For the other direction, let $\MMM = (\LLL, w)$ and $\MMM' = (\LLL',
w')$.  Assume $\THEORY{\MMM} \subseteq \THEORY{\MMM'} $. We need to
show that $\MMM'$ simulates $\MMM$.  In other words, we need to
produce a relation $R \subseteq S \times S'$ where $S$ is the state
set of $\LLL$, $S'$ is the state set for $\LLL'$ and $(w,w') \in R$
and $R$ is a simulation from $(\LLL, w)$ to $ (\LLL', w')$.  Define $R
= \{(x,x') \; | \; \THEORY{ (\LLL, x)} \subseteq \THEORY{ (\LLL',
  x')}\}$.  Clearly, $(w,w') \in R$, as $\THEORY{(\LLL, w)} \subseteq
\THEORY{(\LLL', w')} $.  To show that $R$ is a simulation, assume $x
\xrightarrow{a} y$ in $\LLL$ and $(x,x') \in R$. 
We need to provide a
$y'$ such that $x' \xrightarrow{a} y'$ in $\LLL'$ and $(y,y') \in R$.  
Consider the formula $\MAY{a}\CHAR{(\LLL, y)}$. 
Now $x \models \MAY{a}\CHAR{(\LLL, y)}$, and since $(x,x') \in R$, $x' \models \MAY{a}\CHAR{(\LLL, y)}$.
By the semantic clause for $\MAY{a}$, if $x' \models \MAY{a}\CHAR{(\LLL, y)}$ then there is a $y'$ such that 
$y' \models \CHAR{(\LLL, y)}$.
We need to show $(y,y') \in R$, i.e. that $y \models \phi$ implies $y' \models \phi$ for all $\phi$.
Assume $y \models \phi$. 
Then by the definition of $\CHAR$, $\CHAR{(\LLL, y)} \models \phi$.
Since $y' \models \CHAR{(\LLL, y)}$, $y' \models \phi$. 
So $(y,y') \in R$, as required.

Finally,we need to show that whenever $(x,x') \in R$, then $\lambda(x)
\supseteq \lambda'(x')$.  Assume, first, that $\lambda(x)$ is finite.
Then $(\LLL, x) \models \; ! \; \lambda(x)$.  But as $(x,x') \in R$,
$\THEORY{(\LLL, x)} \subseteq \THEORY{(\LLL', x')} $, so $(\LLL', x')
\models \; ! \; \lambda(x)$.  But, by the semantic clause for $!$,
$(\LLL', x') \models \; ! \; \lambda(x)$ iff $\lambda'(x') \subseteq
\lambda(x)$.  Therefore $\lambda(x) \supseteq \lambda'(x')$.  If, on
the other hand, $\lambda(x)$ is infinite, then $\lambda(x) = \Sigma$
(because the only infinite node labelling that we allow is
$\Sigma$). Every node labelling is a subset of $\Sigma$, so here too,
$\lambda(x) = \Sigma \supseteq \lambda'(x')$.  
\end{proof}

Theorem \ref{theorem:completeLattice} illustrates from a
model-theoretic point of view one dimension of how classical and
eremic logic differ. In classical logic the theory of each model is
complete, and $\THEORY{\CAL{M}} \subseteq \THEORY{\CAL{N}}$ already
implies that $\THEORY{\CAL{M}} = \THEORY{\CAL{N}}$, i.e.~$\CAL{M}$ and
$\CAL{N}$ are elementarily equivalent. \ELFULL{}'s lack of negation
changes this drastically, and gives $\MODELLEQ$ the structure of a
non-trivial bounded lattice as we shall demonstrate below.

But first we show that $\MODELEQ$ is a strictly coarser relation than 
bisimilarity.

\begin{definition}
We say $\RRR$ is a \emph{bisimulation} if $\RRR$ is a simulation from
$\MMM_1$ to $\MMM_2$ and $\RRR^{-1}$ is a simulation from $\MMM_2$ to
$\MMM_1$. By $\BISIM$ we denote the largest bisimulation, and we say
that $\MMM_1$ and $\MMM_2$ are \emph{bisimilar} whenever $\MMM_1
\BISIM \MMM_2$.
\end{definition}

Clearly $\BISIM \subseteq \MODELEQ$, but the two relations do not
coincide: the former is strictly more discriminating than the latter,
i.e.~$\BISIM \subsetneq \MODELEQ$. Figure \ref{figure:counterexample}
shows two models that are $\MODELEQ$-equal but not bisimilar. Note
that this counterexample is \emph{non-deterministic}. That is not
coincidence, because on deterministic eremic models, the two relations
coincide.

\input{figure:counterexample}

Theorem \ref{theorem:completeLattice} has various interesting
consequences.

\begin{corollary}
\begin{enumerate}

\item If $\phi$ has a model then it has a model who's underlying
  transition system is a tree, i.e.~all states except for the root
  have exactly one predecessor, and the root has no predecessors.

\item If $\phi$ has a model then it has a model where every state is
  reachable from the root.

\end{enumerate}
\end{corollary}
\begin{proof}
Both are straightforward because $\MODELEQ$ (and bisimilarity) is
closed under tree-unfoldings as well as under removal of states not
reachable from the root.
\end{proof}


\subsection{Quotienting Models}

\NI The relation $\MODELLEQ$ is not a partial order, only a
pre-order. For example with
\begin{itemize}

\item $\MMM_1 = ( (\{w\}, \{\}, \{w \mapsto \Sigma\}), w)$ and
\item $\MMM_2 = ( (\{v\}, \{\}, \{v \mapsto \Sigma\}), v)$ 

\end{itemize}

\NI we have models where $\MMM_1 \MODELLEQ \MMM_2$ and $\MMM_2
\MODELLEQ \MMM_1$, but the two models are not equal. The difference
between the two models, the name of the unique state, is trival and
not relevant for the formulae they make true. Indeed $\THEORY{\MMM_1}
= \THEORY{\MMM_2}$.  As briefly mentioned in the mathematical
preliminaries (Section \ref{preliminaries}), we obtain a proper
partial-order by simply quotienting models:

\[
   \MMM \MODELEQ \MMM'
      \qquad\text{iff}\qquad
   \MMM \MODELLEQ \MMM' \ \text{and}\ \MMM' \MODELLEQ \MMM.
\]

\NI and the ordering the $\MODELEQ$-equivalence classes as follows:
\[
    [\MMM]_{\MODELEQ} \MODELLEQ [\MMM']_{\MODELEQ}
      \qquad\text{iff}\qquad
    \MMM \MODELLEQ \MMM'.
\]

\NI Since this process is independent for the chosen representatives,
we obtain a partial order. Greatest lower and least upper bounds can also
be computed on representatives:
\[
   \BIGLUB \{[\MMM]_{\MODELEQ} \ |\ \MMM \in S\ \} = [\BIGLUB S]_{\MODELEQ}
\]
whenever $\BIGLUB S$ exists, and likewise for the greated lower bound.
We also define 
\[
   [\MMM]_{\MODELEQ} \models \phi 
      \qquad\text{iff}\qquad
   \MMM \models \phi.
\]

\NI Theorem \ref{theorem:completeLattice} guarantees that the choice
of representative is irrelevant.

In the rest of this text, we will usually be sloppy and work with
concrete models instead of $\MODELEQ$-equivalence classes of models
because the quotienting process is straightfoward and not especially
interesting. We can do this because all relevant constructions in this
text are independent from the specific choice of representative.  Our
Haskell implementation, described in Section \ref{hahahaskell} uses a
slightly different approach: instead of equivalence classes, it uses
canonical representatives.  \martin{add more explanation, and
  integrate better with premiminaries}.

\subsection{Extending $\MODELLEQ$ to a bounded lattice}

It turns out that $\MODELLEQ $ on ($\MODELEQ$-equivalence classes of)
models is not just a partial order, but a bounded lattice, except
that a bottom element is missing.

\begin{definition}
We extend the collection of models with a single \emph{bottom} element
$\bot$, where $\bot \models \phi$ for all $\phi$. We also write $\bot$
for $[\bot]_{\MODELEQ}$.  We extend the relation $\MODELLEQ $ and
stipulate that $\bot \MODELLEQ \MMM$ for all models $\MMM$.
\end{definition}

\begin{theorem}
The collection of (equivalence classes of) models together with
$\bot$, and ordered by $\MODELLEQ$ is a bounded lattice.
\end{theorem}
\begin{proof}
\martin{Why is there no proof?}  Example: The topmost element in the
lattice is the model $( (\{w\}, \{\}, \{w \mapsto \Sigma\}), w)$ (for
some state $w$): this is the model with no transitions and no
transition restrictions.
\end{proof}

\NI We now prove completeness of the rules in Figure
\ref{figure:elAndBangRules}.  The proof requires the development of
the following additional technology which is also useful in other
contexts.

\begin{itemize}

\item An algorithm which gives the simplest model for a formula.

\item An algorithm which gives the a formula characterising a model.

\end{itemize}

\NI We now develop these  in turn and then prove completeness.

\subsection{Computing the simplest model satisfying a formula}
\label{simpl}

Given $\MODELLEQ $, we can define $\SIMPL{\phi}$, the simplest model w.r.t.~$\MODELLEQ $ that
satisfies $\phi$.

\begin{eqnarray*}
  \SIMPL{\top} &\ = \ & ( (\{v\}, \{\}, \{v \mapsto \Sigma\}), v)  \\
  \SIMPL{\fBang A} & = & ( (\{v\}, \{\}, \{v \mapsto A\}), v)  \\
  \SIMPL{\phi_1 \AND \phi_2} & = & \SIMPL{\phi_1} \sqcap \SIMPL{\phi_2}  \\
  \SIMPL{\langle a \rangle \phi} 
     & = & ( (S \cup \{w'\}, \rightarrow \cup (w' \xrightarrow{a} w), \lambda \cup \{w' \mapsto \Sigma\}]), w')  \\
		& & \mbox{where }\SIMPL{\phi} = ( (S, \rightarrow, \lambda), w) \mbox{and } w' \mbox{ is a new state} \\
                &&  \mbox{not appearing in }S 
\end{eqnarray*}

\input{figure:glb}



\NI Note that by our conventions, $\SIMPL{\phi}$ really returns a
$\MODELEQ$-equivalence class of models.

The only complex case is the clause for $\SIMPL{\phi_1 \AND \phi_2}$,
which uses the $\sqcap$ function, defined as follows, where we assume
that the sets of states in the two models are disjoint.

\begin{eqnarray*}
  \bot \sqcap \MMM  &\ =\ &  \bot  \\
  \MMM \sqcap \bot      & = &  \bot  
     \\
  \MMM \sqcap \MMM'
     & = & 
     \mathsf{merge}(\mathcal{L}, \mathcal{L}', \{(w,w')\}) 
     \\
     & & \text{where } \MMM = (\mathcal{L}, w) \text{ and } \MMM' = (\mathcal{L'}, w')
\end{eqnarray*}

\NI The $\mathsf{merge}$ function attempts to merge two LTSs together, given a set of state-identification pairs (a set of pairs of states from the two LTSs that need to be identified).
The state-identification pairs are used to make sure that the resulting model is deterministic.

\begin{eqnarray*}
  \mathsf{merge}(\mathcal{L}, \mathcal{L}', ids) 
     & = & 
  \begin{cases}
    \bot \text{ if } \mathsf{inconsistent}(\mathcal{L}, \mathcal{L}', ids)  \\
    \mathsf{join}(\mathcal{L}, \mathcal{L}') \text{ if } ids = \emptyset  \\
    \mathsf{merge}(\mathcal{L}, \mathcal{L}'', ids')  \\
    \text{ where }  \mathcal{L}'' = \mathsf{applyIds}(ids, \mathcal{L}') \text{ and } ids' = \mathsf{getIds}(\mathcal{L}, \mathcal{L}', ids)
  \end{cases}
\end{eqnarray*}
The $\mathsf{inconsistent}$ predicate is true if there is pair of states in the state-identification set such that the out-transitions of one state is incompatible with the node-labelling on the other state:
\[
\mathsf{inconsistent}(\mathcal{L}, \mathcal{L}', ids) \text{ iff } \exists (w,w') \in ids \; . \; \mathsf{out}(\mathcal{L},w) \nsubseteq \lambda'(w') \; \lor \; \mathsf{out}(\mathcal{L}',w') \nsubseteq \lambda(w)
\]
 \NI Here:
\[
  \mathsf{out}(((S,\rightarrow,\lambda),w)) 
     \ =\  \{ a \fOr \exists w' . w \xrightarrow{a} w'\} 
\]
The $\mathsf{join}$ function takes the union of the two LTSs.
\[
\mathsf{join}((S, \rightarrow,\lambda), (S', \rightarrow', \lambda')) = (S \cup S', \rightarrow \cup \rightarrow', \{\lambda(x) \cap \lambda'(x) \; | \; x \in S \cup S'\})
\]
The $\mathsf{applyIds}$ function applies all the state-identification pairs as substitutions to the Labelled Transition System:
\[
\mathsf{applyIds}(ids, (S, \rightarrow, \lambda)) = (S', \rightarrow', \lambda')
\]
where
\begin{eqnarray*}
S' & = & S \; [ w / w' \; | \; (w,w') \in ids] \\
\rightarrow' & = & \rightarrow \; [ w / w' \; | \; (w,w') \in ids] \\
\lambda' & = & \lambda \; [ w / w' \; | \; (w,w') \in ids]
\end{eqnarray*}
The $\mathsf{getIds}$ function returns the set of extra state-identification pairs that need to be added to respect determinism:
\[
\mathsf{getIds}(\mathcal{L}, \mathcal{L}', ids) = \{(x,x') \; | \; (w,w') \in ids, \exists a \; . \; w \xrightarrow{a} x, w' \xrightarrow{a} x'\}
\]

\NI It is easy to show, by induction on $\phi$, that $\SIMPL{\cdot}$ has the following properties:

\begin{itemize}

\item $\SIMPL{\phi} \models \phi$.

\item If $\MMM' \models \phi$ and  $\MMM \MODELLEQ \MMM'$ then also  $\MMM \models \phi$.\martin{This has nothing to do with $\SIMPL{.}$}
 
\end{itemize}
\martin{There is a lemma/theorem misssing, namely $\MMM \models \phi$ implies $\MMM \MODELLEQ \SIMPL{\phi}$.
this is used in the decision procedure.}

\subsubsection{Showing that $\sqcap$ as defined is the greatest lower bound}
We will show that:
\begin{itemize}
\item
$\MMM \sqcap \MMM' \MODELLEQ \MMM$ and $\MMM \sqcap \MMM' \MODELLEQ \MMM'$
\item
If $\NNN \MODELLEQ \MMM$ and $\NNN \MODELLEQ \MMM'$, then $\NNN \MODELLEQ \MMM \sqcap \MMM'$
\end{itemize}
If $\MMM$, $ \MMM'$ or $\MMM \sqcap \MMM'$ are equal to $\bot$, then we just apply the rule that $\bot \MODELLEQ m$ for all models $m$. 
So let us assume that $\mathsf{consistent}(\MMM, \MMM')$ and that $\MMM \sqcap \MMM'  \neq \bot$.

\begin{proof}
To show $\MMM \sqcap \MMM' \MODELLEQ \MMM$, we need to provide a simulation $\mathcal{R}$ from $\MMM$ to  $\MMM \sqcap \MMM'$.
If $\MMM = ((S,\rightarrow,\lambda),w)$, then define $\mathcal{R}$ as the identity relation on the states of $S$:
\[
\mathcal{R} = \{(x,x) \; | \; x \in S\}
\]
It is straightforward to show that $\mathcal{R}$ as defined is a simulation from $\MMM$ to  $\MMM \sqcap \MMM'$.
If there is a transition $x \xrightarrow{a} y$ in $\MMM$, then by the construction of $\mathsf{merge}$, there is also a transition $x \xrightarrow{a} y$ in $\MMM \sqcap \MMM'$.
We also need to show that $\lambda_{\MMM}(x) \supseteq \lambda_{\MMM \sqcap \MMM'}(x)$ for all states $x$ in $\MMM$. This is immediate from the construction of $\mathsf{merge}$.

\end{proof}

\begin{proof}
To show that $\NNN \MODELLEQ \MMM$ and $\NNN \MODELLEQ \MMM'$ imply $\NNN \MODELLEQ \MMM \sqcap \MMM'$, assume there is a simulation $\mathcal{R}$ from $\MMM$ to $\NNN$ and there is a simulation $\mathcal{R}'$ from $\MMM'$ to $\NNN$.
We need to provide a simulation $\mathcal{R}*$ from $\MMM \sqcap \MMM'$ to $\NNN$.

Assume the states of $\MMM$ and $\MMM'$ are disjoint.
Define:
\[
\mathcal{R}* = \mathcal{R} \cup \mathcal{R}'
\]
We need to show that $\mathcal{R}*$ as defined is a simulation from $\MMM \sqcap \MMM'$ to $\NNN$.

Suppose $x \xrightarrow{a} y$ in $\MMM \sqcap \MMM'$ and that $(x,x_2) \in \mathcal{R} \cup \mathcal{R}'$.
We need to provide a $y_2$ such that $x_2 \xrightarrow{a} y_2$ in  $\NNN$ and $(y,y_2) \in \mathcal{R} \cup \mathcal{R}'$.
If  $x \xrightarrow{a} y$ in $\MMM \sqcap \MMM'$, then, from the definition of $\mathsf{merge}$, either $x \xrightarrow{a} y$ in $\MMM$ or $x \xrightarrow{a} y$ in $\MMM'$. If the former, and given that $\mathcal{R}$ is a simulation from $\MMM$ to $\NNN$, then there is a $y_2$ such that $(y,y_2) \in \mathcal{R}$ and $x_2 \xrightarrow{a} y_2$ in $\NNN$. But, if $(y,y_2) \in \mathcal{R}$, then also $(y,y_2) \in \mathcal{R} \cup \mathcal{R}'$.

Finally, we need to show that if $(x,y) \in \mathcal{R} \cup \mathcal{R}'$ then
\[
\lambda_{\MMM \sqcap \MMM'}(x) \supseteq \lambda_{\NNN}(y)
\]
If $(x,y) \in \mathcal{R} \cup \mathcal{R}'$ then either $(x,y) \in \mathcal{R}$ or $(x,y) \in \mathcal{R}'$.
Assume the former.
Given that $\mathcal{R}$ is a simulation from $\MMM$ to $\NNN$, we know that if $(x,y) \in \mathcal{R}$, then 
\[
\lambda_{\MMM}(x) \supseteq \lambda_{\NNN}(y)
\]
Let $\MMM = ((S,\rightarrow,\lambda),w)$.
If $x \neq w$ (i.e. $x$ is some node other than the root node), then, from the definition of $\mathsf{merge}$, $\lambda_{\MMM \sqcap \MMM'}(x) = \lambda_{\MMM}(x)$.
So, given $\lambda_{\MMM} \supseteq \lambda_{\NNN}(y)$, $\lambda_{\MMM \sqcap \MMM'}(x) \supseteq \lambda_{\NNN}(y)$.
If, on the other hand, $x = w$ (i.e. $x$ is the root node of our pointed model $\MMM$), then, from the definition of $\mathsf{merge}$:
\[
\lambda_{\MMM \sqcap \MMM'}(w) = \lambda_{\MMM}(w) \cap \lambda_{\MMM'}(w')
\]
where $w'$ is the root node of $\MMM'$.
In this case, given $\lambda_{\MMM}(w) \supseteq \lambda_{\NNN}(y)$ and $\lambda_{\MMM'}(w') \supseteq \lambda_{\NNN}(y)$, it follows that $\lambda_{\MMM}(w) \cap \lambda_{\MMM'}(w') \supseteq \lambda_{\NNN}(y)$ and hence $\lambda_{\MMM \sqcap \MMM'}(w) \supseteq \lambda_{\NNN}(y)$.

\end{proof}

\subsection{Computing the least upper bound ($\sqcup$)}
Intuitively, the least upper bound of two models $\MMM$ and $\MMM'$ contains the intersection of the transitions of $\MMM$ and $\MMM'$ for every associated pair of states in $\MMM$ and $\MMM'$, and the union of the node-labellings.

Formally, define the least upper bound ($\sqcup$) of two models as:
\begin{eqnarray*}
\MMM \sqcup \bot & = & \MMM \\
\bot \sqcup \MMM & = & \MMM \\
(\CAL{L},w) \sqcup (\CAL{L}',w') & = & \mathsf{lub}(\CAL{L}, \CAL{L}', (\MMM_\top, z), \{(w, w', z)\})
\end{eqnarray*}
where $\MMM_\top$ is the topmost model $(\mathcal{W}=\{z\}, \rightarrow=\{\}, \lambda=\{z \mapsto \Sigma\})$ for some state $z$.
$\mathsf{lub}$ takes four parameters: the two eremic transition systems $\CAL{L}$ and $\CAL{L}'$, an accumulator representing the constructed result so far, and a list of state triples (each triple contains one state from each of the two input models plus the state of the accumulated result) to consider next.
It is defined as:
\begin{eqnarray*}
\mathsf{lub}(\CAL{L}, \CAL{L}', \MMM, \{\}) & = & \MMM \\
\mathsf{lub}(\CAL{L}, \CAL{L}', ((\mathcal{W}, \rightarrow, \lambda), y), \{(w,w',x)\} \cup R) & = & \mathsf{lub}(\CAL{L}, \CAL{L}', ((\mathcal{W} \cup \mathcal{W}', \rightarrow \cup \rightarrow', \lambda'), y), R' \cup R\}
\end{eqnarray*}
where:
\begin{eqnarray*}
\{(a_i, w_i, w'_i) \;|\; i = 1 ... n\} & = & \mathsf{sharedT}((\CAL{L},w), (\CAL{L}',w')) \\
\mathcal{W}' & = & \{x_i \;|\; i = 1 ... n\} \\
\rightarrow' & = & \{(x, a_i, x_i) \;|\; i = 1 ... n\} \\
\lambda' & = & \lambda [x \mapsto \lambda(w) \cup \lambda(w)'] \\
R' & = & \{(w_i, w'_i, x_i) \;|\; i = 1 ... n\}
\end{eqnarray*}
Here, $\mathsf{sharedT}$ returns the shared transitions between two models, and is defined as:
\[
\mathsf{sharedT}(((\mathcal{W}, \rightarrow, \lambda),w) ((\mathcal{W}', \rightarrow', \lambda'),w')) =  \{(a, x, x') \;|\; w \xrightarrow{a} x \land w' \xrightarrow{a}' x'\}
\]
If $((S*,\rightarrow*,\lambda*),w*) = ((S,\rightarrow,\lambda),w) \sqcup ((S',\rightarrow',\lambda'),w')$ then define
the set $\mathsf{triples}_\mathsf{lub}$ as the set of triples $(x,x',x*) \; | \; x \in S, x' \in S', x* \in S*$ that were used during the construction of $\mathsf{lub}$ above. So $\mathsf{triples}_\mathsf{lub}$ stores the associations between states in $\MMM$, $\MMM'$ and $\MMM \sqcup \MMM'$. 

\input{figure:lub}

\subsubsection{Showing that $\sqcup$ as defined is the least upper bound}
We will show that:
\begin{itemize}
\item
$\MMM \MODELLEQ \MMM \sqcup \MMM'$ and $\MMM' \MODELLEQ \MMM \sqcup \MMM'$
\item
If $\MMM \MODELLEQ \NNN $ and $\MMM' \MODELLEQ \NNN $, then $\MMM \sqcup \MMM' \MODELLEQ \NNN$
\end{itemize}
If $\MMM$ or $ \MMM'$ are equal to $\bot$, then we just apply the rule that $\bot \MODELLEQ m$ for all models $m$. 
So let us assume that neither $\MMM$ not $\MMM'$ are $bot$.

\begin{proof}
To see that $\MMM \MODELLEQ \MMM \sqcup \MMM'$, observe that, by construction of $\sqcup$ above, every transition in $\MMM \sqcup \MMM'$ has a matching transition in $\MMM$, and every node label in  $\MMM \sqcup \MMM'$ is a superset of the corresponding node label in $\MMM$.

To show that $\MMM \MODELLEQ \NNN $ and $\MMM' \MODELLEQ \NNN $ together imply $\MMM \sqcup \MMM' \MODELLEQ \NNN$, assume a simulation $\mathcal{R}$ from $\NNN$ to $\MMM$ and a simulation $\mathcal{R}'$ from $\NNN$ to $\MMM'$.
We need to produce a simulation relation $\mathcal{R}*$ from $\NNN$ to $\MMM \sqcup \MMM' $.
Define
\[
\mathcal{R}* =   \{(x, y*) \; | \; \exists y_1 . \exists y_2 . (x,y_1) \in \mathcal{R}, (x,y_2) \in \mathcal{R}', (y_1,y_2,y*) \in \mathsf{triples}_\mathsf{lub} \}
\]
In other words, $\mathsf{R}*$ contains the pairs corresponding to the pairs in both $\mathsf{R}$ and $\mathsf{R}'$.
We just need to show that $\mathsf{R}*$ as defined is a simulation from $\NNN$ to $\MMM \sqcup \MMM' $.
Assume $(x,x*) \in \mathsf{R}*$ and $x \xrightarrow{a} y$ in $\NNN$. 
We need to produce a $y*$ such that $(x*,y*) \in \mathsf{R}*$ and $x* \xrightarrow{a} y*$ in $\MMM \sqcup \MMM' $.
Given that $\mathcal{R}$ is a simulation from $\NNN$ to $\MMM$, and that  $\mathcal{R}'$ is a simulation from $\NNN$ to $\MMM'$, we know that there is a pair of states $x_1, y_1$ in $\MMM$ and a pair of states $x_2, y_2$ in $\MMM'$ such that $(x,x_1) \in \mathsf{R}$ and $(x,x_2) \in \mathsf{R}'$ and $x_1 \xrightarrow{a} y_1$ in $\MMM$ and $x_2 \xrightarrow{a} y_2$ in $\MMM'$.
Now, from the construction of $\mathsf{lub}$ above, there is a triple $(y_1, y_2, y*) \in \mathsf{triples}_\mathsf{lub}$.
Now, from the construction of $\mathsf{R}*$ above, $(x*,y*) \in \mathsf{R}*$.

Finally, we need to show that for all states $x$ and $y$, if $(x,y) \in \mathsf{R}*, \lambda_{\NNN}(x) \supseteq \lambda_{\MMM \sqcup \MMM'}(y)$.
Given that $\mathcal{R}$ is a simulation from $\NNN$ to $\MMM$, and that  $\mathcal{R}'$ is a simulation from $\NNN$ to $\MMM'$, we know that if $(x,y_1) \in \mathsf{R}$, then $\lambda_\NNN(x) \supseteq \lambda_\MMM(y_1)$.
Similarly, if  $(x,y_2) \in \mathsf{R}$, then $\lambda_\NNN(x) \supseteq \lambda_\MMM'(y_2)$.
Now, from the construction of $\mathsf{lub}$, $\lambda_{\MMM \sqcup \MMM'}(y*) = \lambda_{\MMM}(y_1) \cup \lambda_{\MMM}(y_2)$ for all triples $(y_1, y_2, y*) \in \mathsf{triples}_\mathsf{lub}$. 
So $\lambda_{\NNN}(x) \supseteq \lambda_{\MMM \sqcup \MMM'}(y)$, as required.
\end{proof}

\subsection{A decision procedure for eremic logic}\label{decisionprocedure}

We use the semantic constructions above to provide a linear-time decision procedure.  
The linear time-complexity of the decision procedure is an indication that \ELABR{} can be useful as a
query language in knowledge representation. 

\NI Since \ELABR{} has no connectives for disjunction or implication, its
decision procedure is straightforward and efficient.  Although there
are an infinite number of models which satisfy any expression, the
satisfying models form a lattice with a least upper bound.  The $\SIMPL$
function defined above gives us the minimal model satisfying an
expression.  Using this least upper bound, we can calculate entailment
by checking a \emph{single model}.  To decide whether $p \models q$,
we use the following theorem:

\begin{theorem}\label{theorem:decision}
  The following are equivalent:
  \begin{enumerate}
    \item\label{theorem:decision:1} For all eremic models $\MMM$,
      $\MMM \models \phi$ implies $\MMM \models \psi$.
    \item\label{theorem:decision:2} $\SIMPL{\phi} \models \psi$.
  \end{enumerate}
\end{theorem}

\begin{proof}
The implication from  (\ref{theorem:decision:1}) to
(\ref{theorem:decision:2}) is trivial because $\SIMPL{\phi}$ is a model by construction.

For the reverse direction, assume $\MMM \models \phi$. We need to show
$\MMM \models \psi$.  Now if $\MMM \models \phi$ then $\MMM \MODELLEQ
\SIMPL{\phi}$ (by Lemma \ref{...}).  Further, if $\MMM' \models \xi $
and $\MMM \MODELLEQ \MMM'$ then $\MMM \models \xi $ by Theorem
\ref{completeLattice}. So, substituting $\psi$ for $\xi $ and
$\SIMPL{\phi}$ for $\MMM'$, it follows that $\MMM \models \psi$.
\end{proof}

\NI Given this theorem, the decision procedure is straightforward: to
test if $\phi \models \psi$, we construct $\SIMPL{\phi}$, and then inspect whether
$\SIMPL{\phi} \models \psi$.  Construction of $\SIMPL{\phi}$ is linear in the size of
$\phi$, and computing whether a model satisfies $\psi$ is linear in the size
of $\psi$, so computing whether $\phi \models \psi$ is $O(|\phi|+|\psi|)$.

\martin{Can we say more about the decision procedure? Example? Talk
  about Haskell code?}




