* Have we discussed bisimulation invariance?
* Be consistent. In particular
  - State vs node

  - Names: R Brandom vs Brandom etc

  - What symbols to we use for implication? \rightarrow vs horseshoe

  - Make sure always to be precise about eremic model vs eremic
    transition system

  - POV vs point of view vs point-of-view

  - LTS vs labelled transition system

  - FOL vs first-order logic, EL vs eremic logic

  - Either all definitions are in an explicit \begin{definition}
    environment or none.

  - Term defined should always be \textbf{...} or \textsc{...} etc.

  - FOrmulae vs terms vs sentences

  - What kind of space ! puts between itself and its set. and also before !

  - Book titles always in \emph, e.g. \emph{Philosophical Remarks}?

  - capitalisation, e.g. Eremic Logic vs Eremic logic vs eremic logic etc.

* Talk about binding and precedence in EL formulae.
* Find better names for fragments: e.g. EL[∧, !] isn't exactly snappy. What
about Core etc?
* We have too many correspondence theorems, remove names.
* If we remove [!-Left] from the rules, then prove it as a lemma
  or use it as an example of derivable rules.
* Explain the terms "eremic" and "tantum" (if we stick with them)
* Should we have a section about material incompatibility and how
  Gamma |- phi iff Gamma, not phi inconsistent does not hold in EL?
* Factor out the stuff that I use in compactness by translation and Richard
  in the theorem that states "If a formula φ is satisfiable, then
  there is a finite tree-like model of height |φ| and branching factor
  σ(φ) that satisfies φ."
  I mean the stuff about erasing superfluous labels.
* Make sure we have \qed at the end of every proof. Better:
  put it into the latex macro.

* Make sure figures look coherent, and live in suitable places.
* Remove macros that are not used.
* Put a full stop after \proof
* Since most (all) examples don't use the change over time
of the structure of exclusion, we have an even more basic 
fragment where all !A is not under a may. (Or something like
that.) Discuss and investigate
* Ask philosophers about historical precursors for using exlusion
  to approach human language
* Say what ranges over what, e.g. \frac{M} over models, X, Y over
  formulae, etc.  Be consistent about this.

* Use descriptive names, why \mu(X) for the simplest model satisfying
  $X$?  would not simp(X) or something like that more readable?

* EL allows us to do  intra-atomic inferences that are not possible in FOL.
But are we capturing all intra-atomic inferences or is EL missing
some? What is the expressivity of EL? This question might not have
a clear answer but it might be worthwhile considering.
* Finalise the name of the logic. I am going to check with my friend
  Tim Whitmarsh one more time that "Eremic Logic" is the best name for
  it.
* Find a better name for !A than "bang A".
About the question how to name !A I think the obvious names are
something like this:

   Just A
   Only A
   Nothing but A
   Solely A 
   At most

Whatever we choose, we should also have a scientific sounding term
that relates to !  as conjunction relates to /\ as well as disjunction
to \/.  In Latin we can choose tantum, nisi, solo, solus and in Greek:
mono (μόνο). If we go creative we could simply say

   Erem A
* What about the dual "at least A" operator? We should have a discussion.
* Given the size of the paper, maybe we can have a table of content and/or
  an index?
* Add generous acknowledgements (in particular if we get feedback from others)
* What about quantification over actions? Section 11 just quantifies over individuals.
* Should we have proof in the appendix at all?
* I recommend to use the following order of presentation in Chapters 2 and 3.

  - Formulae
  - Models and the satisfaction relation.
  - Rules and axioms
  - Soundness of rules and axioms
  - Completeness of rules and axioms
  - Other stuff (Translation into FOL, decision procedure etc).

  I think it might also help if we relegate standard proofs to the
  appendix.  For example we could just state the soundness theorem in
  the main body of the paper, prove 2 or 3 interesting cases, and have
  the rest in the appendix. I also prefer it if ther proof rules are
  all in one figure, rather than distributed over a couple of pages.

  - Rules and axioms in figures.

  - Easy proof go in the appendix

* Give more examples.

* be consistent on capitalisation.

* Timetable: 13.May to 16.May, can we finish it?

* Find possible reviewers (please add more):

  - Michael Wooldridge http://www.cs.ox.ac.uk/people/michael.wooldridge/
  - Robert Brandom http://www.pitt.edu/~rbrandom/
  - Marek Sergot http://www.doc.ic.ac.uk/~mjs/
  - Marcus Kracht http://wwwhomes.uni-bielefeld.de/mkracht/index-en.html
  - Graham White and Paulo Oliva at QMUL
  - Database people like Moshe Vardi (who else?)
  - Bernhard Reus at Sussex
  - Billiejoe Charlton
  - Aram Lintzel
  - Bat
  - http://rasmuskrendsvig.dk/ 
  - Coalgebraic modal guys (like Alexander Kurz) but not sure

* Could it make sense to prepare a little video presentation (using
  Screenflow, or recording professionally), maybe 15 minutes, to
  introduce the material? This could make it more accessible to
  non-technical audiences.)

* Prepare Haskell decision procedure. Put on Github. Write
  instructions on how to use.
* THink about how to interface the paper with Versu.  Versu—A
  Simulationist Storytelling System

* Think about seminars (Sussex, Imperial, Oxford, QMUL which others?)

* Related work: 

  - Investgations into negation
  - Philosophical stuff
  - Logics for knowledge representation
  - Standard Modal Logic stuff
  - HM Logic
  - Linear logic (additive conjunction)

* The rule (! left) is not used in the completeness proof. Why not?
* go through old emails and list ideas and issues that we discussed
* Remove all commented out LaTeX including macros.
* Put the footnote on complexity of binders in main intro body.
add later something about how this is reflected in EL queries.

   Yes. (We currently use one-way pattern matching rather than
   unification).  When inserting a statement in a database based on
   FOPL (e.g. inserting the statement that the traffic light is
   green), the inference engine has to make forward-chaining
   inferences to see which statements to delete (e.g. it needs to use
   your FOPL rules for traffic lights only being one colour to infer
   that the traffic light is no longer orange).  But in EL, the
   removal of incompatible propositions happens without the need for
   inference over universally quantified propositions. We can see
   directly from the node labelling of the current node which
   statements can no longer be true.
