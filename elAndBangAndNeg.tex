\section{\Cathoristic{} and negation}\label{ELAndNegation}

\NI We have presented \cathoristic{} as a language, without negation, that can express incompatible claims .
In this section, we study how \cathoristic{}  is enriched when we add the negation operator.

\subsection{Syntax and semantics}

\begin{definition}
Given a set $\Sigma$ of symbols, the \emph{formulae of \cathoristic{}
  with negation} are given by the following grammar.
\begin{GRAMMAR}
  \phi 
     &\quad ::= \quad & 
   \top \fOr \neg \phi \fOr \phi \land \psi \fOr \langle a \rangle \phi \fOr \fBang A 
\end{GRAMMAR}

\NI We can now define disjunction $\phi \lor \psi$ and implication
$\phi \IMPLIES \psi$ by de Morgan duality: $\phi \OR \psi$ is short
for $\neg (\neg \phi \land \neg \psi )$, and $\phi \IMPLIES \psi$  abbreviates
$\neg\phi \OR \psi$.
\end{definition}

The semantics of \cathoristic\ with negation is just that of plain
\cathoristic\, except for the obvious clause for negation.
\begin{eqnarray*}
\MMM \models \neg \phi &\quad\mbox{ iff }\quad& \MMM \nvDash \phi  
%\MMM \models \phi \lor \psi &\mbox{ iff }& \MMM \models \phi \text{ or }   \MMM \models \psi
\end{eqnarray*}

\NI Negation is a core operation of classical logic, and its absence makes
\cathoristic{} unusual. In order to understand \cathoristic{} better, we
now investigate how negation can be seen as a definable abbreviation
in \cathoristic{} with disjunction. The key idea is that 
\[
   \neg \MAY{a}{\phi}
\]
can be false in two ways: either there is no $a$-labelled action at the
current state - or there is, but $\phi$ is false. Both arms of this
disjunction can be expressed in \cathoristic{}:

\begin{itemize}

\item $!\Sigma \setminus \{a\}$.

\item $\MAY{a}{\neg \phi}$.

\end{itemize}

\NI Hence, we can see $\neg \MAY{a}{\phi}$ as a shorthand for 
\[
   !(\Sigma \setminus \{a\}) \OR \MAY{a}{\neg \phi}
\]

\NI Negation still occurs in this term, but prefixing a formula of
lower complexity.

This leaves the question of negating the tantum. That's easy: when
$\neg !A$, then clearly the current state can do an action $a \notin
A$. In other words
\[
   \BIGOR_{a \in \Sigma}\MAY{a}{\TRUE}
\]

\NI When $\Sigma$ is infinite, then so is the disjunction.

Note that both the negation of the modality and the negation of
the tantum involve the set $\Sigma$ of actions. 
So far, we have defined negation with respect to
the whole (possibly infinite) set $\Sigma$. For technical reasons, we
generalise negation and define it with respect to a \emph{finite}
subset $S \subseteq \Sigma$. We use this finitely-restricted version of
negation in the decision procedure below.

\begin{definition}
The function $\neg_{S}(\phi)$ removes negation from $\phi$
relative to a finite subset $S \subseteq \Sigma$:

\begin{align*}
  \neg_{S}(\top) &\ =\  \bot  &
  \neg_S(\bot) &\ =\  \top  \\
  \neg_S(\phi \land \psi) &\ =\  \neg_S(\phi) \lor \neg_S(\psi)  &
  \neg_S(\phi \lor \psi) &\ =\  \neg_S(\phi) \land \neg_S(\psi)  \\
  \neg_S(\langle a \rangle \phi) &\ =\  \fBang(S-\{a\}) \lor \langle a \rangle \neg_S(\phi)  &
  \neg_S(\fBang A) &\ =\  \bigvee_{a \in S - A} \langle a \rangle \top
\end{align*}


\end{definition}

\subsection{Decision procedure}

\NI We can use the fact that \cathoristic\ has a quadratic-time
decision procedure to build an exponential-time decision procedure for
\cathoristic\ with negation.  Given $\phi \models \psi$, let $S =
\mathsf{symbols}(\phi) \cup \mathsf{symbols}(\psi) \cup \{a\}$ - where
$a$ is a new symbol which does not occur in $\phi$ or $\psi$.  First,
translate away all negations in $\phi$ using $\neg_S()$ as defined in
Section 1.4.  Let the result be $\phi'$.  Second, reduce $\phi'$ to
Disjunctive Normal Form by repeated application of the rewrite rules:
\begin{eqnarray*}
\phi \land (\psi \lor \xi) & \quad \leadsto \quad& (\phi \land \psi) \lor (\phi \land \xi)  \\
(\phi \lor \psi) \land \xi & \leadsto & (\phi \land \xi) \lor (\psi \land \xi) 
\end{eqnarray*}
Let the resulting disjuncts be $\phi_1, ..., \phi_n$. 
Now 
\[
\phi \models \psi \quad\text{ iff }\quad \phi_i \models \psi \text{ for all } i = 1 .. n
\]
Now, to check whether each $\phi_i \models \psi$, 
we will construct a series of $S$-extensions of $\phi_i$, and check whether each such $S$-extension satisfies $\psi$.
We shall define the $S$ extensions of
an annotated model $\MMM$ as all models which extend the states of
$\MMM$ with extra transitions taken from $S$ which respect the state
labelling on $\MMM$.  
\begin{definition}
Given an cathoristic transition system $(\mathcal{W},\rightarrow,\lambda)$,  and a set $S$ of symbols, then $(\mathcal{W'},\rightarrow',\lambda')$ is a {\bf $S$-extension} of $(\mathcal{W},\rightarrow,\lambda)$ if it is a valid LTS (recall Definition 1) and for all $(x,a,y) \in \rightarrow'$, either:
\begin{itemize} 
\item
$(x, a, y) \in \rightarrow$,  or;
\item
 $x \in \mathcal{W}$ and $a \in S$ and $y$ is a new state not appearing elsewhere in $\mathcal{W}$ or $\mathcal{W'}$.
\end{itemize}
\end{definition}
In other words, $\MMM'$ is an extension of an annotated model $\MMM$, if all its transitions are either from $\MMM$ or involve states of $\MMM$ transitioning via elements of $S$ to new states not appearing in $\MMM$ or $\MMM'$.
The number of extensions can quickly grow very large.
If the model $\MMM$ has $n$ states, then the number of possible extensions is:
\[
({2^{|S|}})^n
\] 
But recall that we are computing these extensions in order to verify $\psi$. So we can make a significant optimisation by restricting the height of each tree to $|\psi|$.

Now $\phi_i \models \psi$ if and only if all $S$-extensions of $\SIMPL{\phi_i}$ satisfy $\psi$.  
So, to check
whether $\phi_i \models \psi$, we enumerate the $S$-extensions of
$\SIMPL{\phi_i}$ (there are a finite number of such extensions - the
exact number is exponential in the size of $\SIMPL{\phi_i}$) and check
for each one whether it satisfies $\psi$.
There is a Haskell implementation of this decision procedure available at \cite{HaskellImplementation}.
