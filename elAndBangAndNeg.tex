\section{EL$[\land, !, \neg]$}


\subsection{Syntax}

Given a set $\Sigma$ of symbols, with $a$ ranging over
$\Sigma$, and $A$ ranging over (possibly empty) sequences of
elements of $\Sigma$, the formulae of EL$[\land, !, \neg]$ are
given by\footnote{We include $\lor$, even though it is definable in
formulae of $\neg$ and $\land$, because our decision procedure involves
translating formulae into Disjunctive Normal Form.}:

\begin{GRAMMAR}
  \phi 
     &\quad ::= \quad & 
   \top \fOr \bot \fOr \neg \phi \fOr \phi_1 \land \phi_2 \fOr\phi_1 \lor \phi_2 \fOr \langle a \rangle \phi \fOr \fBang A 
\end{GRAMMAR}

\subsection{Semantics}

The semantics of EL$[\land, !, \neg]$ is just as in EL$[\land, !]$
above, except for the obvious clauses for negation and disjunction:
\begin{eqnarray*}
(l,w) & \models & \neg \phi \mbox{ iff } (l,w) \nvDash \phi \\
(l,w) & \models & \phi \lor \psi \mbox{ iff } (l,w) \models \phi \text{ or }   (l,w) models \psi
\end{eqnarray*}

\subsection{Negation}

Negation can be translated away using the following rewrite rules,
\emph{relative to a certain set $\mathcal{S} \subseteq \Sigma$ of symbols}:

\begin{eqnarray*}
  \neg_{\mathcal{S}}(\top) & \ = \ & \bot  \\
  \neg_\mathcal{S}(\bot) & \ = \ & \top  \\
  \neg_\mathcal{S}(\phi_1 \land \phi_2) & \ = \ & \neg_\mathcal{S}(\phi_1) \lor \neg_\mathcal{S}(\phi_2)  \\
  \neg_\mathcal{S}(\phi_1 \lor \phi_2) & \ = \ & \neg_\mathcal{S}(\phi_1) \land \neg_\mathcal{S}(\phi_2)  \\
  \neg_\mathcal{S}(\langle a \rangle \phi) & \ = \ & \fBang(\mathcal{S}-\{a\}) \lor \langle a \rangle \neg_\mathcal{S}(\phi)  \\
  \neg_\mathcal{S}(\fBang A) & \ = \ & \bigvee_{a \in \mathcal{S} - A} \langle a \rangle \top
\end{eqnarray*}

\NI Note that, if $\mathcal{S}$ is infinite, then the last two clauses will generate infinitary formulae.

\subsection{Restricting the Law of the Excluded Middle to a Determinate Set of Possibilities}

Given a formula $p$ and particular set $\mathcal{S}$ of symbols, then we
cannot hope to prove

\[
\models p \lor \neg_\mathcal{S}(p)
\]

\NI For example, let $p$ be $\langle a \rangle \top$ and $\mathcal{S} = \{a,
b\}$.  Now

\[
\neg_\mathcal{S}(\langle a \rangle \top) \; = \; ! \{b\} \lor \langle a \rangle \neg_\mathcal{S}(\top) \; =  \; ! \{b\} \lor \langle a \rangle \bot
\]

\NI So, in this case:
\[
p \lor \neg p \; = \; \langle a \rangle \top \; \lor \; ! \{b\} \; \lor \; \langle a \rangle \bot
\]

\NI Now this will not in general be valid - it will be false in any model
which contains a transition from the root to any other symbol not in
$\mathcal{S}$, for example: $c$.

But if we \emph{fix in advance the set of available options} (in this
case restricting to the set $\mathcal{S}$), then we can prove the excluded
middle:
\[
!\{a, b\} \models \; \langle a \rangle \top \; \lor \; ! \{b\} \; \lor \; \langle a \rangle \bot
\]

\NI More generally, let $\mathsf{path}(\phi)$ be the set of
symbol-sequences in $\phi$.  So for example:

\[
\mathsf{path}(\langle a \rangle (\langle b \rangle \top \land \langle c \rangle \langle d \rangle \top)) = \{(), (a), (a, b), (a, c, d)\}
\]

\NI Then the following is valid for any formula $\phi$ (letting
$\mathcal{S} = \sigma(\phi)$):

\[
\bigwedge_{(a_1, ..., a_n) \in \mathsf{path}(\phi)} \langle a_1 \rangle ... \langle a_n \rangle \fBang \mathcal{S} \models \phi \lor \neg_\mathcal{S} (\phi)
\]

\subsubsection{Discussion: Precisifying the Negation. }

\NI If someone asserts that, say, Jack does not support Manchester United,
we have so far said very little.  Until we know the \emph{range of
  football teams} he could support, we don't know what the negation
amounts to.  Until we have some more determinate information about the
range of possible choices, there are an \emph{indefinite} number of
ways in which this could be true.  But if we knew that the only
possible teams Jack could support are Manchester United, Arsenal or
Chelsea, then suddenly our negation has some determinate content.
SNEL captures this intuition.  Once a negated formula has been
precisified by specifying the range of allowable options (via the $!$
operator), the negated claim can be made precise, and the law of
excluded middle can be proven.

\subsubsection{Discussion: Negation as Infinitary Disjunction. }
As is well known the existential quantifier of Predicate Logic can be translated into an infinitary disjunction of propositions in Propositional Logic.

Analogously, given an infinite set $\mathcal{S}$ of symbols, the negation of propositional logic can be translated into an infinitary disjunction of formulae in SNEL.



\section{A Naive Decision Procedure}
Define $|\phi|$ as the degree of $\phi$:
\begin{eqnarray*}
|\top| & = & 0  \\
|\bot| & = & 0  \\
|\neg \phi| & = & | \phi |  \\
|\phi_1 \land \phi_2| & = & \mathsf{max}(| \phi_1 |, | \phi_2|)  \\
|\phi_1 \lor \phi_2| & = & \mathsf{max}(| \phi_1 |, | \phi_2|)  \\
|\langle a \rangle \phi | & = & 1 + | \phi |  \\
| \fBang S | & = & 1 
\end{eqnarray*}
Define the $\mathsf{symbols}$ of a formula as:
\begin{eqnarray*}
\mathsf{symbols}(\top) & = & \{\}  \\
\mathsf{symbols}(\bot) & = & \{\}  \\
\mathsf{symbols}(\neg \phi) & = & \mathsf{symbols}(\phi)  \\
\mathsf{symbols}(\phi_1 \land \phi_2) & = &\mathsf{symbols}(\phi_1) \cup \mathsf{symbols}(\phi_2)  \\
\mathsf{symbols}(\phi_1 \lor \phi_2) & = &\mathsf{symbols}(\phi_1) \cup \mathsf{symbols}(\phi_2)  \\
\mathsf{symbols}(\langle a \rangle \phi) & = & \{a\} \cup \mathsf{symbols}(\phi)  \\
\mathsf{symbols}(\fBang S) & = & S 
\end{eqnarray*}
Now define $\sigma(\phi)$ as:
\[
\sigma(\phi) = |\mathsf{symbols}(\phi)| + 1
\]
Then we can prove the following theorem:

\begin{theorem}
If a formula $\phi$ is satisfiable, then there is a finite tree-like model of height $|\phi|$ and branching factor $\sigma(\phi)$ that satisfies $\phi$.
\end{theorem}
\begin{proof}
Take the original  model $(l,w)$ that satisfies $\phi$.
Let $(l',w)$ be the generated sub-model starting at $w$. 
It is well known that generated sub-models satisfy the same formulae, so $(l',w)$ also satisfies $\phi$.
Now (by Proposition 2.15 of ``Modal Logic'') we can construct a tree-like model $(l'',w)$ of branching factor $\sigma(\phi)+1$ that also satisfies $\phi$.
Now take the restriction of $(l'',w)$ to height $|\phi|$.
Now $(l'',w)$ bisimulates $(l,w)$ to degree $|\phi|$.
But (by Proposition 2.31 of ``Modal Logic''), if two models bisimulate to degree $|\phi|$, then they agree on all formulae of degree $|\phi|$. So the restriction of the tree-like model satisfies $\phi$.
\end{proof}

To use Theorem 1 as a decision procedure: if we have a claim $P_1, ..., P_n \models Q$,  let $ \phi = \bigwedge P_i \land \neg Q$, and look for a satisfying model of $\phi$. By Theorem 1, we only need to search a finite number of trees of height $\LEQ |\phi|$ and branching factor $\LEQ \sigma(\phi)$.

\subsection{The Need for an Additional Symbol}
Note that the function $\sigma(\phi) = |\mathsf{symbols}(\phi)| + 1$ adds one additional symbol to the symbols in $\phi$. Why is this?

Consider the invalid claim that says that nothing ever exists:
\[
\top \nvDash \fBang []
\]
To see that it is invalid, we need to consider a model which includes a transition using a new symbol $\nu$ which is not in $\mathsf{symbols}(\phi)$. (After all, in this case, $\mathsf{symbols}(\top \land \neg  \fBang []) = []$). 
So, when enumerating finite models that might satisfy $\phi$, the symbols we need to consider are:
\[
\mathsf{symbols}(\phi) \cup \{\nu\}
\]
where $\nu \notin \mathsf{symbols}(\phi)$. Another case where the extra $\nu$ symbol is needed is for showing that:
\[
\langle a \rangle \top \nvDash \fBang [a]
\]
To show this we need a model which satisfies $\langle a \rangle \top \land \neg \nvDash \fBang [a]$.
Any satisfying counter model includes an extra transition from the root using a symbol other than $a$.

\subsection{Doubly-Exponential Search Space}
The number of trees grows at a rate which is doubly exponential.
At level $0$, there is just one state.
At level $1$, there are $\sigma(\phi)$ states.
At level $h$, there are $\sigma(\phi)^h$ states.
The total height of the tree is $|\phi|$, so the total number of states in the model is:
\[
\sum_{i=0}^{|\phi|} (\sigma(\phi))^i
\]
The different models are distinguished by which of these states are used. 
Each state is either used or unused.
So the total number of models is no more than $2 ^ {\sum_{i=0}^{|\phi|} (\sigma(\phi))^i}$.
(In fact it is significantly less than this upper bound because there are restrictions on which combinations of states can be used and unused: a child cannot be used if any of its ancestors are unused).

To get the exact number of trees for a given height $h$ and branching factor $b$, define the following recursive function:
\begin{eqnarray*}
a(0) & = & 1 \\
a(n+1) & = & (1+a(n))^b 
\end{eqnarray*}
Then the number of trees is $a(h)$.
This quickly grows enormous, as the following table shows, for $b = 3$:
\begin{center}
\begin{tabular}{ r | r }
h & a(h) \\
\hline
0 & 1 \\
1 & 8 \\
2 & 729 \\
3 & 389017000 \\
4 & 58871587162270593034051001
%4 & 5.8871587e+25 \\
\end{tabular}
\end{center}
    
\section{A More Efficient DecisionProcedure}
We can use the fact that the $[\land, \fBang]$ fragment of SNEL has a linear-time decision procedure to build an exponential-time decision procedure for EL $[\land, \fBang, \neg]$:

Given a claim $\phi \models \psi$, let $\mathcal{S} = \mathsf{symbols}(\phi) \cup \mathsf{symbols}(\psi) \cup \{\nu\}$ (where $\nu$ is a new symbol which does not occur in $\phi$ or $\psi$).
First, translate away all negations in $\phi$ using $\neg_\mathcal{S}()$ as defined in Section 1.4.
Let the result be $\phi'$.
Second, reduce $\phi'$ to Disjunctive Normal Form by repeated application of the rewrite rules:
\begin{eqnarray*}
\phi \land (\psi \lor \xi) & \leadsto & (\phi \land \psi) \lor (\phi \land \xi)  \\
(\phi \lor \psi) \land \xi & \leadsto & (\phi \land \xi) \lor (\psi \land \xi) 
\end{eqnarray*}
Let the resulting disjuncts be $\phi_1, ..., \phi_n$. 
Now 
\[
\phi \models \psi \mbox{ iff } \forall \phi_{i=1}^n \phi_i \models \psi
\]
Now, to check whether each $\phi_i \models \psi$, we will construct a model of $\psi_i$ (in linear time). 
Now define the $\mathcal{S}$ extensions of an annotated model $\MMM$ as all models which extend the states of $\MMM$ with extra transitions taken from $\mathcal{S}$ which respect the state labelling on $\MMM$.
Now $\phi_i \models \psi$ if and only if all $\mathcal{S}$-extensions of $\SIMPL{\phi_i}$ satisfy $\psi$.
So, to check whether $\phi_i \models \psi$, we enumerate the $\mathcal{S}$-extensions of $\SIMPL{\phi_i}$ (there are a finite number of such extensions - the exact number is exponential in the size of $\SIMPL{\phi_i}$) and check for each one whether it satisfies $\psi$.

To fill out this sketch, I will describe the structure of the annotated model, define the $\mu$ function, and show how to compute the extensions of an annotated model relative to a set $\mathcal{S}$ of symbols.


\subsection{Computing the Extensions of a Model}

Recall that, to check whether $\phi_i \models \psi$, we enumerate the $\mathcal{S}$-extensions of $\SIMPL{\phi_i}$ (there are a finite number of such extensions - the exact number is exponential in the size of $\SIMPL{\phi_i}$) and check for each one whether it satisfies $\psi$.

\begin{definition}
Given an eremic transition system $(\mathcal{W},\rightarrow,\lambda)$,  and a set $\mathcal{S}$ of symbols, then $(\mathcal{W'},\rightarrow',\lambda')$ is a {\bf $\mathcal{S}$-extension} of $(\mathcal{W},\rightarrow,\lambda)$ if it is a valid LTS (recall Definition 1) and for all $(x,a,y) \in \rightarrow'$, either:
\begin{itemize} 
\item
$(x, a, y) \in \rightarrow$,  or;
\item
 $x \in \mathcal{W}$ and $a \in \mathcal{S}$ and $y$ is a new state not appearing elsewhere in $\mathcal{W}$ or $\mathcal{W'}$.
\end{itemize}
\end{definition}
In other words, $\MMM'$ is an extension of an annotated model $\MMM$, if all its transitions are either from $\MMM$ or involve states of $\MMM$ transitioning via elements of $\mathcal{S}$ to new states not appearing in $\MMM$ or $\MMM'$.

The number of extensions can quickly grow very large.
If the model $\MMM$ has $n$ states, then the number of possible extensions is:
\[
({2^{|\mathcal{S}|}})^n
\] 
But recall that we are computing these extensions in order to verify $\psi$. So we can make a significant optimisation by restricting the height of each tree to $|\psi|$.

\section{Relating EL to Propositional Logic and Hennessy-Milner Logic}
Consider the following six languages:
\begin{center}
\begin{tabular}{ l | r }
Language & Description \\
\hline
PL[$\land$] & Propositional Logic restricted to the $\land$ operator \\
HML[$\land$] & Hennessy-Milner Logic restricted to the $\land$ operator \\
EL[$\land, !$] & Eremic Logic restricted to the $\land$ and $\fBang$ operators \\
PL [$\land, \neg$] & Full Propositional Logic \\
HML [$\land, \neg$] & Full Hennessy-Milner Logic \\
EL [$\land, !, \neg$] & Full Eremic Logic \\
\end{tabular}
\end{center}
Now the top three languages are simple to the point of triviality. In each case:
\begin{itemize}
\item
There is no facility for expressing disjunction
\item
Every formula that is satisfiable has a simplest satisfying model
\item
There is a simple linear-time decision procedure
\end{itemize}
But there are two ways in which EL[$\land, !$]  is significantly more expressive.

Firstly, EL[$\land, !$], unlike either PL[$\land$] or HML[$\land$] , is expressive enough to be able to distinguish between any two models that are not bisimilar. (See Theorem \ref{hennessymilnertheorem}).

The second way in which EL[$\land, !$] is significantly more expressive than both PL[$\land$] and HML[$\land$] is in its ability to express incompatibility.
No two formulae of PL[$\land$] (or HML[$\land$] ) are incompatible with each other. 
But many pairs of formulae of EL[$\land, !$] are incompatible.
(For example: $\langle a \rangle \top$ and $! []$). 
Because EL[$\land, !$]  is expressive enough to be able to make incompatible claims, it satisfies Brandom's property of {\bf Incompatibility Semantics\footnote{$\INC{p}$ is the set of sets of formulae incompatible with $p$.}}:
\[
p \models q \mbox{ iff } \INC{q} \subseteq \INC{p}
\]
EL[$\land, !$]  is the \emph{only} logic with a linear-time decision procedure that is expressive enough to respect Incompatibility Semantics.

The bottom three language can all be decided in exponential time.
But HML is more expressive than PL, and EL [$\land, !, \neg$]  is more expressive than full HML. 
\begin{proposition}
Full HML  is more expressive than full PL.
\end{proposition}
To see this, fix a PL with the nullary operator $\top$ plus an infinite number of propositional atoms $P_{(i,j)}$, indexed by $i$ and $j$.
Now translate each formula of HML via the rules:
\begin{eqnarray*}
t(\top)  & = & \top  \\
t(\phi \land \psi) & = & t(\phi) \land t(\psi)  \\
t(\neg \phi) & = & \neg t(\phi)   \\
t(\langle a_i \rangle \phi_j) & = & P_{(i,j)} 
\end{eqnarray*}
Now to show that HML is more expressive, we show that there are formulae $\phi$ and $\psi$ of HML such that
\[
\phi \models_{HML} \psi \mbox{ but } t(\phi) \nvDash_{PL} t(\psi)
\]
For example, let $\phi = \langle a \rangle \langle b \rangle \top$ and $\psi = \langle a \rangle \top$.
Clearly, $\phi \models_{HML} \psi$. But $t(\phi) = P_{(i,j)}$ and $t(\psi) = P_{(i',j')}$ for some $i,j,i',j'$, and there are no entailments in PL between arbitrary propositional atoms.

\begin{proposition}
EL [$\land, !, \neg$]  is more expressive than full HML
\end{proposition}
Given a background set $\Sigma$ of symbols, the formula $\fBang A$ of EL can be translated into HML as:
\[
\bigwedge_{a \in \Sigma - A} \neg \langle a \rangle \top
\]
But if $\Sigma$ is infinite, then this is an infinitary disjunction.

\section{EL With Quantifiers}
Now that $!$ is a nullary operator on sequences of symbols (rather than a unary operator on propositions, as it was before), we can expand EL to include quantifiers in the obvious way.

Using quantifiers, we can now express typing judgements directly in the language. For example, to say that a person's gender can only be male or female, we would write:
\[
\forall X \langle X \rangle \langle gender \rangle \rightarrow \langle X \rangle \langle gender \rangle !\{male, female\}
\]
To say that every person must have exactly one gender, we can write:
\[
\forall X  \langle X \rangle \langle gender \rangle \rightarrow \exists Y \langle X \rangle \langle gender \rangle (\langle Y \rangle \top \land \fBang \{Y\})
\]


