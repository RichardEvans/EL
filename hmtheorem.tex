\section{Hennessy-Milner theory}

\martin{This section needs revision.}

\subsection{Comparing \ELABR{} with Hennessy-Milner Logic}

Section \ref{standardTranslation} investigated the relationship
between \ELABR{} and first-order logic. Now we compare \ELABR{} with
a logic that is much closer in spirit: Hennessy-Milner logic
\cite{HennessyM:alglawfndac}, a modal logic designed to reason about
process calculi. Indeed the present shape of \ELABR{} owes to
Hennessy-Milner logic. We now contrast both by translation from \ELABR{} into Hennessy-Milner logic \martin{why not the other way?}. 
This will reveal more clearly than the translation into
first-order logic where \ELABR{} is novel.

Given a set $\Sigma$ of symbols, with $s$ ranging over
$\Sigma$, the \emph{formulae} of Hennessy-Milner logic are given
by the following grammar:
\begin{GRAMMAR}
  \phi 
     &\quad ::= \quad & 
  \top \fOr \phi_1 \AND \phi_2 \fOr \langle s \rangle \phi \fOr \neg \phi 
\end{GRAMMAR}

\NI Note that many presentations use infinite conjunction. However,
that's not required in the present context.

 \emph{Models} of Hennessy-Milner logic are the pairs $(W,
\rightarrow, w)$ where $(S, \rightarrow)$ is a labelled transition
system over $S$, and $w \in W$.  The \emph{satisfaction relation} $(l,
w) \models \phi$ is given by the following inductive clauses.

\[
\begin{array}{lclcl}
  (l,w) & \models & \top  \\
  (l,w) & \models & \phi_1 \AND \phi_2 &\  \mbox{ iff }\  & (l,w)  \models \phi_1 \mbox { and } (l,w) \models \phi_2  \\
  (l,w) & \models & \langle a \rangle \phi & \mbox{ iff } & \mbox{ there is a } w \xrightarrow{a} w' \mbox { such that } (l,w') \models \phi  \\
  (l,w) & \models & \neg \phi & \mbox{ iff } & (l,w)  \nvDash \phi 
\end{array}
\]

\NI We can now see the two differences between \ELFULL{}, and
Hennessy-Milner logic, one syntactic, the other semantic.

\begin{itemize}

\item Syntactically, \ELABR{} has the transition-restriction operator ($!$)
  instead of logical negation ($\neg$).

\item Semantically, an \ELABR{} model has an additional state-labelling,
  describing the allowable transitions from each vertex.

\end{itemize}

\NI We translate formulae of \ELABR{} into HML using the function $t$:\martin{maybe use $\SEMB{X}$ instead?}

\begin{eqnarray*}
  t(\top) & \ = \ & \top  \\
  t(\phi_1 \AND \phi_2) & \ = \ & t(\phi_1) \AND t(\phi_2)  \\
  t(\langle a \rangle \phi) & \ = \ & \langle a \rangle t(\phi)  \\
  t(! A) & \ = \ & \bigwedge_{a \in \Sigma - A} \neg \langle a \rangle \top 
\end{eqnarray*}

\NI If $\Sigma$ is an infinite set, then the translation of a $!$
formula will be an infinitary formula.  If $\Sigma$ is finite,
then the size\martin{Define the size of a formula. Maybe when formulae
  are defined.} of the HML formula will be of the order of $n *
| \Sigma |$ larger than the original \ELABR{} formula (where $n$ is the
number of $!$ operators occurring in the \ELABR{} formula).

\martin{Say something more interesting about this translation!}

We can now see why in Hennessy-Milner logic without negation $p \equiv
p'$ does \emph{not} entail $p \BISIM p'$

\begin{GRAMMAR}
  \phi 
    &\quad ::= \quad&
  \top \fOr \phi_1 \AND \phi_2  \fOr \langle a \rangle \phi
\end{GRAMMAR}

\input{figure:hml}

\NI Consider Figure \ref{figure:hml}.  Here, $x \equiv x'$ - they both
satisfy the sub formulae of $\langle a \rangle (\langle b \rangle \top
\AND \langle c \rangle \top)$.  But there is no bisimulation between
$x$ and $x'$ ($y_1$ cannot be matched with $y'$ because $y'$ has an
additional outgoing $c$-transition).

If we remove negation, HML is insufficiently expressive to distinguish
between these two non-bisimilar models.  When we restore negation, we
can distinguish between these models via the formula:

\[
   \langle a \rangle \neg \langle c \rangle \top
\]

\NI Similarly, \ELABR{} is able to distinguish between these models via the
formula:

\[
  \langle a \rangle ! \{b\}
\]

\NI \ELABR{}, also, has the expressive capacity to distinguish between
non-bisimilar models. If the LTSs are finitely-branching, it can
simulate negation (in innermost scope) via the width restriction
operator !
