\section{Conclusion}\label{conclusion}


\subsection{Open problems} 

\QUOTATION{As long as a branch of science offers an abundance of
  problems, so long it is alive; a lack of problems foreshadows
  extinction or the cessation of independent development. \textsc{D. Hilbert.}}

In the spirit of Hilbert's quote, I'm including this section to
encourage us to think about interesting open problems, ideally of
varying degrees of difficulty. What I recommend to avoid are vague
problems, there are enough of those already. I'm looking for clearcut
questions, i.e. we know when we've succeeded in solving them.  A good
question would ideally come with a plausible story why solving the
problem is important.  Here are some examples to get the ball rolling.

\begin{enumerate}

\item A question that has been fruitful in modal logic has been which
  fragment of first-order logic corresponds to modal formulae?  Van
  Benthem established that modal logic is the fragment of first-order
  logic invariant under bisimulation. What is the the fragment
  corresponding to eremic logic? Our Theorem
  \ref{theorem:completeLattice} suggests to look at closure under
  mutual simulation. Van Benthem's result was generalised to monadic
  second order by Janin and Walukiewicz
  \cite{JaninD:expcomotpmcwrtmsol} who showed that the bisimulation
  invariant fragment of monadic second-order logic is Kozen's modal
  $\mu$-calculus, an extension of modal logic with fixpoint operators.

\item Do we have 'cut-elimination', ie. can we remove
  [\RULENAME{Transitivity}]?  And do we have the sub-formula property?

\item What about double negation and the constructive/classical
  reasoning distinction?  How does it appear in \ELABR{}?

\item Is there a reasonable Curry-Howard correspondence for \ELFULL{}?

\item Mathematical logic knows three substantially different
  approaches towards proving compactness: first G\"odel's original
  approach, refined by Morley and many others, uses proof rules and
  the completeness theorem. It thus mixes syntax and semantics. Second
  are proofs by translation, such as our's in Section
  \ref{completenessProof}, that piggy-back on the compactness of other
  logics. Finally, a purely semantic approach often uses
  ultra-products as a tool for 'gluing' together the models that
  guarantee finite satisfiability. Ultra-products are quotients of
  reduced products by an ultra-filter. The conditions defining
  ultra-filters are carefully chosen to ensure that the quotiented
  reduced product is indeed an appropriate model with nice properties
  such as \L{}o\'{s}' theorem. In particular, for $U$ to be an
  ultra-filter over some set $S$, for each $A \subseteq S$, either $A$
  or its complemnet $S\setminus A$ must be in $U$. This axiom clearly
  reflects the semantics of negation. But eremic logic doesn't have
  negation. So what would an appropriate equivalent of ultra-filters
  for eremic logic look like that can be used to prove compactness
  directly on models?

\item\label{conclusion:openProblems:2}  Develop a theory of SAT solving based on \ELABR{} rather than
  propositional logic.

\item Once (\ref{conclusion:openProblems:2}) works, develop efficient
  solvers for \ELABR{} satisfiability.

\item\label{conclusion:openProblems:4} Develop machine-oriented proof-rules that relate to \ELABR{}
  in the way that unification/resolution relate to first-order logic.

\item Once (\ref{conclusion:openProblems:4}) works, develop a
  programming language that relates to \ELABR{} in the same way
  Prolog relates to classical logic.

\item Develop and axiomatise an \ELABR{} $\mu$-calulus, following
  Kozen's modal-$\mu$-calculus.

\item Can we give a good characterisation of the first-order fragment
  identified by the standard translation of \ELFULL{}?
  
\item Even if not explicitly defined, conventional modal logics have
  not just a may modality, but also its dual, the must modality. This
  is a direct consequence of the presence of negation: $\MUST{a}{\phi}
  = \neg \MAY{a}{\neg \phi}$. In eremic logic the situation is
  different: since negation is not available, adding $\MUST{a}{\phi}$
  is a substantial change to the logic: for example the processes in
  Figure \ref{figure:counterexample}, indistinguishable by eremic
  formulae, are separated by 
  \[
     \MUST{a}{\MAY{b}{}},
  \]
  assuming the usual semantics: $(\LLL, s) \models \MUST{a}{\phi}$ if
  $s \TRANS{a} t$ implies that $(\LLL, t) \models \phi$. That means
  Theorem \ref{theorem:completeLattice} fails. What notion of model
  equivalence does elementary equivalence become in this scenario?
  What do complete proof rules look like?

  Similar questions can be asked for other additional primitives. If negation is 
  available, the formula
  \[
     \MAY{a}{\neg \MAY{b}{} }
  \]
  separates the afromentioned examples. If we add implication instead,
  negation becomes definable: $\neg \phi = \phi \rightarrow \bot$.


\end{enumerate}

